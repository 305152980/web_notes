Vite 的基本使用
		创建 Vite 的项目
		 	在命令行，按照如下顺序执行命令，即可基于 Vite 创建 vue3.x 的工程化项目：
				npm init vite-app 项目名
				cd 项目名
				npm install
				npm run dev
		梳理项目的结构
			使用 Vite 创建的项目结构如下：
				node_modules		目录用来存放第三方依赖包。
				public			是公共的静态资源目录。
				src			是项目的源代码目录（程序员写的所有代码都要放在此目录下）。
				.gitignore		是 Git 的配置文件。
				index.html		是 SPA 单页面应用程序中唯一的 HTML 页面。
				package.json		是配置项目的包管理文件。
			在 src 这个项目源代码目录之下，包含了如下的文件和文件夹：
				assets 目录		用来存放项目中所有的静态资源文件（css、fonts 等）。
				components 目录		用来存放项目中所有的自定义组件。
				App.vue			是项目的根组件。
				index.css		是项目的全局样式表文件。
				main.js			是整个项目的打包入口文件。
		Vite 项目的运行流程
			在工程化的项目中，Vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。其中：
				1、App.vue		用来编写待渲染的模板结构；
				2、index.html		中需要预留一个 el 区域；
				3、main.js		把 App.vue 渲染到了 index.html 所预留的区域中。
		Vite 的主要任务是创建一个 Vue 根实例。
			1、从 vue 中导入 createApp 函数；
				import { createApp } from 'vue';
			2、创建一个 Vue 根组件，并将其导入至 main.js 文件；
				import App from './App.vue';
			3、使用 createApp 函数在 Vue 根组件的基础上创建 Vue 根实例；
				const app = createApp(App);
			4、将 Vue 根实例挂载到 #app 容器中；
				app.mount('#app');



Vue3
	vue3.x 的特点
		1、性能提升。
			打包大小减少41%，初次渲染快55%，更新渲染快133%，内存占用减少54%......
		2、源码的升级。
			使用 Proxy 方法代替 defineProperty 方法实现响应式，重写虚拟 DOM 的实现和重写 Tree-Shaking 的实现......
		3、拥抱 TypeScript。
		4、新特新。
			1、Composition API。
				setup 配置
				ref 和 reactive
				watch 和 watchEffect
				provide 和 inject
				......
			2、新的内置组件。
				Fragment
				Teleport
				Suspense
			3、其他的改变。
				新的生命周期钩子
				data 选项应始终被申明为一个函数
				移除 keyCode 支持作为 v-on 的修饰符
				......
	组件的生命周期
		vue3.x 可以继续使用 vue2.x 的生命周期钩子，但最后两个生命周期钩子被改名。
			beforeDestroy 改名为 beforeUnmount。
			destroyed 改名为 unmounted。
		vue3.x 也提供了 Composition API 形式的生命周期钩子，它与 vue2.x 生命周期钩子的对应关系如下：
			beforeCreate()	==>	无				创建组件实例前
			created()	==>	无				创建组件实例后			
			beforeMount()	==>	onBeforeMount(() => {})		组件实例挂载到 DOM 前		
			mounted()	==>	onMounted(() => {})		组件实例挂载到 DOM 后		
			beforeUpdate()	==>	onBeforeUpdate(() => {})	组件实例更新前	
			updated()	==>	onUpdated(() => {})		组件实例更新后		
			beforeUnmount() ==>	onBeforeUnmount(() => {})	组件实例销毁前	
			unmounted()	==>	无				组件实例销毁后
	常用 Composition API
		setup 函数
			简介
				setup 函数是一个组件选项，它在组件创建之前和 props 解析之后被执行，它是组合式 API 的入口。
				注意：
					1、setup 函数为在 beforeCreate 钩子函数之前被调用执行，此时的 this 是 undefined；
					2、组件中所用到的数据、方法、监听器、计算属性、生命周期钩子等均要在 setup 函数中进行配置。
			用法
				setup(props, context) { return }
			参数
				props：对象。包含组件外部传递过来，且在组件内部声明接收了的属性。
				context：上下文对象。包含：
					attrs: 对象。包含组件外部传递过来，但没有在组件内部声明接收的属性，相当于 this.$attrs。
					slots: 对象。包含组件接收到的插槽内容，相当于 this.$slots。
					emit: 对象。包含组件接收到的自定义事件，相当于 this.$emit。
						注意：vue3.x 中的自定义事件需要在组件中声明接收。
			注意
				1、因为 setup 函数的 props 参数是响应式的，所以对它不能使用 ES6 解构，这样会消除 prop 参数的响应性；
				1、setup 函数可以返回普通 JS 对象供模板使用；setup 函数也可以返回渲染函数直接替换掉模板结构，这个在函数式组件中广泛被使用；
				3、setup 函数不能是一个 async 函数，因为 async 函数的返回值是 Promise 对象。（也可以返回一个 Promise 对象，但需要 Suspense 和异步组件的配合。）
		ref 函数
			简介
				接受一个内部值并返回一个响应式且可变的 ref 对象。该 ref 对象仅有一个 .value 属性，这个属性指向接收的内部值。
			用法
				<template>
					<div>{{refValue}}</div>
				</template>
				<script>
					import { ref } from 'vue';
					export default {
						setup () {
							ver initValue = 0;
							const refValue = ref(initValue);
							// 读
							console.log(refValue.value);
							// 写
							refValue.value = 1;
							return { refValue }
						}
					}
				</script>
			注意：
				1、接收的数据可以是：简单数据类型数据、也可以是复杂数据类型数据（对象和数组）；
				2、简单数据类型数据的响应式是依靠 defineProperty 方法实现的单层响应式；
				3、复杂数据类型数据（对象和数组）的响应式是依靠 reactive 函数实现的深层响应式。
					注意：reactive 函数是对 Proxy() 方法的封装。
			应用
				接收接口返回值的时候经常用到 ref 函数，因为返回值的数据类型可能不确定。
					const data = ref(null);
					data.value = res.data;
		reactive 函数
			简介
				接受一个复杂数据类型数据（对象和数组）并返回一个深层响应式的复杂数据类型数据（对象和数组）。
			用法
				<template>
					<div>{{reactValue}}</div>
				</template>
				<script>
					import { reactive } from 'vue';
					export default {
						setup () {
							var initValue = {
								name: 'zhangsan',
								age: 18
							};
							const reactValue = reactive(initValue);
							// 读。直接读，数组亦如此。
							console.log(reactValue.name);
							// 写。直接写，数组亦如此。
							reactValue.age = 28;
							return { reactValue }
						}
					}
				</script>
		ref 函数和 reactive 函数对比
			从接收数据的数据类型角度对比：
				ref 函数可以接收简单数据类型数据和复杂数据类型数据（对象和数组）。
				reactive 函数不能接收简单数据类型数据，只能接收复杂数据类型数据（对象和数组）。
			从实现响应式数据原理角度对比：
				ref 函数是通过 defineProperty 方法实现的单层响应式（数据劫持）。
				reactive 函数是通过 Proxy 方法实现的深层响应式（数据代理）, 并通过 Reflect 对象来操作目标“对象/数组”的“属性/元素”（反射）。
			从响应式数据使用角度对比：
				ref 函数返回的响应式数据在操作数据时需要使用 .value。
				reactive 函数返回的响应式数据可以直接操作数据的属性或元素。
		toRef 函数
			作用：依赖源响应式对象的某个属性生成一个 ref 响应式数据，该 ref 响应式数据会保持对源响应式对象相对应属性的响应式连接。
			用法
				依赖 ref 定义的源响应式对象
					const state = ref({
						foo: 1,
						bar: 2
					});
					const fooRef = toRef(state.value, 'foo');
					state.value.foo++;
					console.log(fooRef.value); // 2
					fooRef.value++;
					console.log(state.value.foo); // 3
					return { fooRef }
				依赖 reactive 定义的源响应式对象
					const state = reactive({
						foo: 1,
						bar: 2
					});
					const fooRef = toRef(state, 'foo');
					state.foo++;
					console.log(fooRef.value); // 2
					fooRef.value++;
					console.log(state.foo); // 3
					return { fooRef }
			应用：setup 函数返回值的解构。
		toRefs 函数
			作用：依赖源响应式对象生成一个普通对象，该普通对象的每个属性都是一个 ref 响应式数据，并且该属性会保持对源响应式对象相对应属性的响应式连接。
			用法
				依赖 ref 定义的源响应式对象
					const state = ref({
						foo: 1,
						bar: 2
					});
					const stateAsRefs = toRefs(state.value);
					state.value.foo++;
					console.log(stateAsRefs.foo.value) // 2
					stateAsRefs.foo.value++
					console.log(state.value.foo) // 3
					return { ...state.value }
				依赖 reactive 定义的源响应式对象
					const state = reactive({
						foo: 1,
						bar: 2
					});
					const stateAsRefs = toRefs(state);
					state.foo++;
					console.log(stateAsRefs.foo.value) // 2
					stateAsRefs.foo.value++
					console.log(state.foo) // 3
					return { ...state }
			应用：setup 函数返回值的解构。
		computed 函数
			<script>
				import { reactive, computed } from 'vue';
				export default {
					setup () {
						const person = reactive({
							firstName: 'zhang',
							lastName: 'san'
						});
						// 简写
						person.fullName_simple = computed(() => {
							return person.firstName + '-' + person.lastName
						});
						// 完整
						person.fullName_whole = computed({
							get() {
								return person.firstName + '-' + person.lastName
							},
							set(value) {
								const nameArr = value.split('-');
								person.firstName = nameArr[0];
								person.lastName = nameArr[1];
							}
						});
						return { person }
					}
				}
			</script>
		watchEffect 函数
			简介
				立即执行传入的函数参数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数，相当于没有返回值的 computed 函数。
			用法
				<script>
					import { ref, watchEffect } from 'vue';
					export default {
						setup () {
							const count = ref(0);
							watchEffect(() => console.log(count.value));
							setTimeout(() => {
								count.value++;
							}, 100);
						}
					}
				</script>
		watch 函数
			对 ref 定义的数据的监听
				1、单个简单数据类型数据的监听。
					watch(valueName, (newValue, oldValue) => {
						......
					}, { immediate: true })	
					注意：这里的 valueName 不能写成 valueName.value。
				2、多个简单数据类型数据的监听。
					watch([valueName1, valueName2], (newValue, oldValue) => {
						......
					}, { immediate: true })
					注意：这里的 valueName 不能写成 valueName.value。
				3、单个复杂数据类型数据（对象或数组）的监听。
					// 写法一。
					watch(objName, (newValue, oldValue) => {
						......
					}, { immediate: true, deep: true })
					// 写法二。
					watch(objName.value, (newValue, oldValue) => {
						......
					}, { immediate: true})
					注意：
						1、此种情况下 oldValue 参数接收到的不是 objName 的旧值而是 objName 的新值；
						2、写法二中 watch 函数强制开启了深度监听，此时 watch 函数的 deep 配置无效。
				4、单个复杂数据类型数据（对象或数组）的某个属性或元素的监听。
					watch(() => objName.value.prop, (newValue, oldValue) => {
						......
					}, { immediate: true })
					注意：
						1、objName.value.prop 也可以是 objName.value.objProp.prop 这样的多层取值；
						2、此种情况下，如果 “属性或元素” 不是简单数据类型数据，那么 oldValue 参数接收到的不是 “属性或元素” 的旧值而是 “属性或元素” 的新值；
						3、此种情况下，如果 “属性或元素” 不是简单数据类型数据，那么 watch 函数的深度监听需要手动配置 deep 来开启。
				5、单个复杂数据类型数据（对象或数组）的某些属性或元素的监听。
					watch([() => objName.value.prop1, () => objName.value.prop2], (newValue, oldValue) => {
						......
					}, { immediate: true })	
					注意：
						1、objName.value.prop 也可以是 objName.value.objProp.prop 这样的多层取值；
						2、此种情况下，如果 “属性或元素” 不是简单数据类型数据，那么 oldValue 参数接收到的不是 “属性或元素” 的旧值而是 “属性或元素” 的新值；
						3、此种情况下，如果 “属性或元素” 不是简单数据类型数据，那么 watch 函数的深度监听需要手动配置 deep 来开启。
			对 reactive 定义的数据的监听
				1、单个复杂数据类型数据（对象或数组）的监听。
					watch(objName, (newValue, oldValue) => {
						......
					}, { immediate: true })
					注意：
						1、此种情况下 oldValue 参数接收到的不是 objName 的旧值而是 objName 的新值；
						2、此种情况下 watch 函数强制开启了深度监听，此种情况下 watch 函数的 deep 配置无效。
				2、单个复杂数据类型数据（对象或数组）的某个属性或元素的监听。
					watch(() => objName.prop, (newValue, oldValue) => {
						......
					}, { immediate: true })
					注意：
						1、objName.prop 也可以是 objName.objProp.prop 这样的多层取值；
						2、此种情况下，如果 “属性或元素” 不是简单数据类型数据，那么 oldValue 参数接收到的不是 “属性或元素” 的旧值而是 “属性或元素” 的新值；
						3、此种情况下，如果 “属性或元素” 不是简单数据类型数据，那么 watch 函数的深度监听需要手动配置 deep 来开启。
				3、单个复杂数据类型数据（对象或数组）的某些属性或元素的监听。
					watch([() => objName.prop1, () => objName.prop2], (newValue, oldValue) => {
						......
					}, { immediate: true })	
					注意：
						1、objName.prop 也可以是 objName.objProp.prop 这样的多层取值；
						2、此种情况下，如果 “属性或元素” 不是简单数据类型数据，那么 oldValue 参数接收到的不是 “属性或元素” 的旧值而是 “属性或元素” 的新值；
						3、此种情况下，如果 “属性或元素” 不是简单数据类型数据，那么 watch 函数的深度监听需要手动配置 deep 来开启。
	其它 Composition API
	Vue 自定义指令
		版本差异：
			在 vue2.x 的项目中使用自定义指令时: mounted 应改为 bind、updated 应改为 update。
		私有自定义指令
			在每个 Vue 组件中，可以在 directives 节点下声明私有自定义指令。
				<!-- 在使用自定义指令时，需要加上 v- 前缀。 -->
				<input v-focus />
				// 声明自定义指令，指令的名字是 focus。
				directives: {
					focus: {
						// 当绑定指令的元素被插入到 DOM 中时会自动触发 mounted 函数。
						mounted(el) {
							// el 是绑定指令的 DOM 元素。
							el.focus();
						}
					}
				}
		全局自定义指令
			全局自定义指令需要通过“单页面应用程序的实例对象”进行声明。
				<input v-focus />
				app.directive('focus', {
					mounted(el) {
						el.focus();
					}
				});
		updated 函数
			mounted 函数只会在“绑定指令的元素”第一次被插入到 DOM 时被调用，updated 函数会在每次 DOM 更新完成后再次被调用。
				<input v-focus />
				app.directive('focus', {
					mounted(el) {
						el.focus();
					},
					updated(el) {
						el.focus();
					}
				});
				注意：如果 mounted 和 updated 函数中的逻辑完全相同，则自定义指令可以简写成如下格式：
					app.directive('focus', {
						el => {
							el.focus();
						}
					});
		自定义指令的参数
			在绑定自定义指令时，可以通过“等号”的形式为指令绑定具体的参数值。
				<!-- 使用自定义指令。 -->
				<input v-color="'red'" />
				// 定义自定义指令。
				app.directive('color', {
					(el, binding) => {
						// binding.value 就是通过“等号”为自定义指令绑定的值。
						el.style.coor = binding.value;
					}
				});
	Vue 路由（vue-router 4.x 版本）
		vue-router 版本
			前后版本使用差别较小。
			vue-router 目前有 3.x 和 4.x 的版本。其中：vue-router 3.x 只能结合 vue2.x 进行使用，vue-router 4.x 只能结合 vue3.x 进行使用。
		vue-router 原理
			动态组件
				前端路由实现的基础。
				Vue 提供了内置的 <component> 组件，专门用来实现组件的动态渲染。
					<component is="要渲染的组件名称"></component>
				keep-alive
					默认情况下，切换动态组件时无法保持组件的状态。此时可以使用 Vue 内置的 <keep-alive> 组件来保持动态组件的状态。
						<keep-alive>
							<component is="要渲染的组件名称"></component>
						</keep-alive>
			前端路由的工作步骤
				1、用户点击了页面上的路由链接；
				2、导致了 URL 地址栏中的 Hash 值发生了变化；
				3、前端路由监听了到 Hash 值的变化；
				4、前端路由把当前 Hash 值对应的组件渲染到浏览器中。
				结论：前端路由指的是 Hash 值与组件之间的对应关系。
			实现简易的前端路由
				原理
					1、导入并注册 MyHome、MyMovie、MyAbout 三个子组件；
					2、通过 <component> 标签的 is 属性，动态切换要显示的子组件；
					3、在父组件中声明 3 个 <a> 链接，通过点击不同的 <a> 链接，来切换浏览器地址栏中的 Hash 值；
					4、在父组件的 created 生命周期函数中监听浏览器地址栏中 Hash 值的变化，以此来动态切换要展示的组件名称。
				代码
					created() {
						window.onhashchange = () => {
							switch(location.hash) {
								case '#/home':
									this.comName = 'my-home';
									break
								case '#/movie':
									this.comName = 'my-movie';
									break
								case '#/about':
									this.comName = 'my-about';
									break
							}
						}
					}
		vue-router 基础
			使用步骤
				1、在项目中安装 vue-router；
					npm install vue-router@next -S
				2、定义需要路由的组件；
				3、声明路由链接和占位符；
					<template>
						<!-- 声明路由链接 -->
						<router-link to="......"></router-link>
						<!-- 声明路由占位符 -->
						<router-view></router-view>
					</template>
				4、创建路由模块；
					在项目中创建 router.js 路由模块，模块中按照如下 4 个步骤创建并获得路由的实例对象：
						1、从 vue-router 中按需导入两个方法；
							// createRouter 方法用于创建路由的实例对象。
							// createWebHashHistory 方法用于指定路由的 hash 模式。
							import { createRouter, createWebHashHistory } from 'vue-router';
						2、导入需要使用路由控制的组件；
						3、创建路由的实例对象；
							const router = createRouter({
								history: createWebHashHistory(),
								routes: []
							});
						4、向外共享路由的实例对象。
							export default router
				5、在 main.js 中导入并挂载路由模块。
					import router from './router';
					app.use(router);
		vue-router 高级
			重定向路由
				重定向路由指的是：在访问地址 A 的时候，强制跳转到地址 C ，从而展示特定的组件页面。
				通过路由规则的 redirect 属性指定一个新的路由地址可以很方便地设置重定向路由。
					const router = createRouter({
						history: createWebHashHistory(),
						routes: [
							{ path: '/', redirect: '/login' },
							{ path: '/login', component: Login }
						]
					});
			嵌套路由
				通过路由实现组件的嵌套展示，叫做嵌套路由，也叫做父子路由。用法如下：
					1、声明子路由链接和占位符；
					2、在父路由规则中，通过 children 属性嵌套声明子路由规则。
						const router = createRouter({
							history: createWebHashHistory(),
							routes: [
								{
								      path: "/home",
								      redirect: "/home/users",
								      component: Home,
								      children: [
										{ path: "users || /home/users", component: Users },
										{ path: "rights", component: Rights },
										{ path: "goods", component: Goods }
								      ]
								}
							]
						});
					注意：路由中的开头斜线代表的是根路径。
			命名路由
				通过 name 属性为路由规则定义名称的方式，叫做命名路由。
					const router = createRouter({
						history: createWebHashHistory(),
						routes: [
							{ path: '/login', component: Login, name: 'login' }
						]
					});
				注意：命名路由的 name 值不能重复，必须保证唯一性。
				使用命名路由实现声明式导航
					<router-link :to="{ name: 'mov', params: { id: 3 } }">go to movie</router-link>
				使用命名路由实现编程式导航
					this.$router.push({ name: 'mov', params: { id: 3 } });
			动态路由
				const router = createRouter({});
				router.addRoutes([{}, {}]);
			路由导航与传参
				组件中的路由导航与传参
					通过调用 API 实现路由导航的方式叫做编程式导航，通过点击链接实现路由导航的方式叫做声明式导航。
					声明式导航与传参
						<router-link to="/user?userId=123">User</router-link>
						<router-link :to="`/user?userId=${userId}`">User</router-link>
						<router-link :to="{ path: '/user', query: { userId: 123 }}">User</router-link>
						<router-link :to="{ name: 'user', query: { userId: 123 }}">User</router-link>
						<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
						注意：path 是不能和 params 一同使用的。
					编程式导航与传参
						this.$router.go(n);
						this.$router.push('/user?userId=123');
						this.$router.push(`/user?userId=${userId}`);
						this.$router.push({ path: '/user', query: { userId: 123 }});
						this.$router.push({ name: 'user', query: { userId: 123 }});
						this.$router.push({ name: 'user', params: { userId: 123 }});
						注意：path 是不能和 params 一同使用的。
					注意：在组件中使用 this.$route.params.id 和 this.$route.query.id 可以接收传递过来的参数。
				路由模块中的 params 传参
					路由模块中的 params 传参也叫动态路由。
					路由模块中
						const router = createRouter({
							history: createWebHashHistory(),
							routes: [{ path: "/user/:userId", component: User }]
						});
					对应组件中
						传递参数
							<router-link to="/user/123">User</router-link>
							<router-link :to="`/user/${userId}`">User</router-link>
						接收参数
							$route 接收路由参数
								$route.params.参数名
							props 接收路由参数
								// 首先在定义路由规则时声明 props: true。
								{ path: "/user/:userId", component: User, props: true }
								export default {
									// 接收路由规则中匹配到的参数。
									props: ['userId']
								}
			路由导航守卫
				全局路由导航守卫
					全局导航守卫会拦截每个路由规则，从而对每个路由进行访问权限的控制。
						// 创建路由实例对象。
						const router = createRouter({ ...... });
						// 全局前置路由导航守卫。
						router.beforeEach((to, from, next) => {
						  next();
						});
						// 全局后置路由导航守卫。
						router.afterEach((to, from) => {});
					注意：
						1、在前置守卫方法中如果不声明 next 形参，则默认允许用户访问每一个路由；
						2、在前置守卫方法中如果声明了 next 形参，则必须调用 next() 函数，否则不允许用户访问任何一个路由。
							next()：直接放行；
							next(false)：强制停留在当前页面；
							next('URL')：强制跳转到指定页面。
				独享路由导航守卫
					在对应的路由对象里添加 beforeEnter: beforeEnter(to, from, next) { next(); } 属性。
					注意：在独享路由导航守卫中没有后置守卫方法。
				组件内路由导航守卫
					进入路由组件时调用 beforeRouteEnter 钩子。
						beforeRouteEnter(to, from, next) { next(); }
					离开路由组件时调用 afterRouteEnter 钩子。
						afterRouteEnter(to, from, next) { next(); }
					注意：这个使用的少，用到时建议去查看官方文档。
			路由元信息
				定义路由的时候可以配置 meta 字段：
					const router = new VueRouter({
						routes: [{
							path: '/foo',
							component: Foo,
							children: [{
								path: 'bar',
								component: Bar,
								// a meta field
								meta: { requiresAuth: true }
							}]
						}]
					})
			路由激活样式
				方式一：使用默认的高亮 class 类。
					被激活的路由链接默认会应用 router-link-active 类，开发者可以使用此类名选择器为激活的路由链接设置高亮的样式。
						// 在全局样式文件中定义此样式。
						.router-link-active {
							background-color: red;
							color: white;
							font-weight: bold;
						}
				方式二：自定义路由的高亮 class 类。
					在创建路由的实例对象时，开发者可以基于 linkActiveClass 属性自定义路由链接被激活时所应用的类。
						const router = createRouter({
							history: createWebHashHistory(),
							// 默认的路由激活类名会被覆盖。
							linkActiveClass: 'router-active',
							routes: []
						});		
		

		
	ref 属性
		作用
			ref 被用来给 DOM 元素或子组件注册引用信息。引用信息将会被注册在父组件的 $refs 对象上。
			如果在 DOM 元素上使用，引用指向的就是该 DOM 元素；如果在子组件上使用，引用指向的就是该子组件实例。
		用法
			1、引用单个 DOM 元素或组件实例。
				<template> 
					<div ref="root">This is a root element</div>
				</template>
				<script>
					import { ref, onMounted } from 'vue';
					export default {
						setup() {
							// const root = null;
							const root = ref(null);
							onMounted(() => {
								// DOM 元素将在初始渲染后分配给 ref。
								// console.log(root);
								console.log(root.value);
							});
							return { root }
						}
					}
				</script>
			2、引用 v-for 遍历的 DOM 元素或组件实例。
				<template>
					<div v-for="(item, i) in list" :ref="el => { if(el) divs[i] = el }">
						{{ item }}
					</div>
				</template>
				<script>
					import { ref, reactive, onBeforeUpdate } from 'vue';
					export default {
						setup() {
							const list = reactive([1, 2, 3]);
							// const divs = [];
							const divs = ref([]);
							// 确保在每次更新之前重置 ref。
							onBeforeUpdate(() => {
								// divs = [];
								divs.value = [];
							});
							return { list, divs }
						}
					}
				</script>
	组件通讯
		父向子单项传值
			父组件中的代码
				<Son :valueName="valName"></Son>
				setup() {
					const valName = ref(0);
					return { valName }
				}
			子组件中的代码
				props: {
					valueName: {
						type: Number,
						default: 0
					}
				}
				setup(props) {
					console.log(props.valueName);
				}
		子向父单项传值
			父组件中的代码
				<Son @funcName="fnName"></Son>
				setup() {
					const fnName = param => {
						......
					};
					return { fnName }
				}
			子组件中的代码
				setup(props, { emit }) {
					......
					emit('funcName', value);
				}
